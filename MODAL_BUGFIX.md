# Исправление бага с отображением неправильного контента в модальном окне

## Дата исправления
2025-10-14

## Описание проблемы

При клике на карточку новости модальное окно открывалось с контентом **другого поста** (обычно первого в списке), несмотря на то, что сами карточки отображали корректные данные.

---

## Причина бага: Race Condition (Состояние гонки)

### Что происходило в коде:

```typescript
const handleReadMore = async (post: NewsPost) => {
  setLoadingDetail(true);
  setSelectedNews(post);        // ← 1. Установка начального поста
  setCurrentImageIndex(0);

  // ... API запрос ...

  setSelectedNews(finalDetail);  // ← 2. Перезапись полными данными
}
```

### Сценарий проблемы:

1. **Пользователь кликает на Пост A**
   - `setSelectedNews(постA)` - отображается заголовок поста A
   - Начинается загрузка детальных данных A

2. **Пользователь быстро кликает на Пост B** (пока A еще грузится)
   - `setSelectedNews(постB)` - заголовок меняется на B
   - Начинается загрузка детальных данных B

3. **Загрузка A завершается первой**
   - `setSelectedNews(детали A)` - **ПЕРЕЗАПИСЫВАЕТ пост B на A!**
   - Модальное окно показывает контент A

4. **Загрузка B завершается**
   - `setSelectedNews(детали B)` - Теперь показывает B
   - Но пользователь уже запутался

### Почему это происходило:

JavaScript асинхронный, и нет гарантии, что запросы завершатся в том же порядке, в котором были отправлены. Более того, предыдущие запросы продолжали выполняться, даже когда был кликнут другой пост.

---

## Решение: AbortController

### Что изменено:

#### 1. Добавлено состояние для контроля запросов

```typescript
const [abortController, setAbortController] = useState<AbortController | null>(null);
```

#### 2. Отмена предыдущих запросов

```typescript
const handleReadMore = async (post: NewsPost) => {
  // Отменяем предыдущий запрос, если он еще выполняется
  if (abortController) {
    abortController.abort();
  }

  // Создаем новый контроллер для текущего запроса
  const newAbortController = new AbortController();
  setAbortController(newAbortController);

  // ... остальной код ...

  try {
    // Передаем signal в fetch для возможности отмены
    const response = await fetch(url, { signal: newAbortController.signal });

    // ... обработка данных ...

    // Устанавливаем данные ТОЛЬКО если запрос не был отменен
    if (!newAbortController.signal.aborted) {
      setSelectedNews(finalDetail);
    }
  } catch (err) {
    // Игнорируем ошибки отмены
    if ((err as Error).name !== 'AbortError') {
      console.error('Error loading news detail:', err);
    }
  }
}
```

#### 3. Отмена при закрытии модального окна

```typescript
const closeModal = () => {
  if (abortController) {
    abortController.abort();  // Отменяем загрузку при закрытии
  }
  setSelectedNews(null);
  setCurrentImageIndex(0);
  setIsImageZoomed(false);
};
```

---

## Как это работает

### До исправления:
```
Клик на Пост A → Запрос A начат
  ↓
Клик на Пост B → Запрос B начат (A продолжает грузиться)
  ↓
Ответ A получен → Показывает А ❌ (НЕПРАВИЛЬНО!)
  ↓
Ответ B получен → Показывает B
```

### После исправления:
```
Клик на Пост A → Запрос A начат
  ↓
Клик на Пост B → Запрос A ОТМЕНЕН → Запрос B начат
  ↓
Ответ A игнорируется (был отменен)
  ↓
Ответ B получен → Показывает B ✅ (ПРАВИЛЬНО!)
```

---

## Дополнительные исправления

### Унификация логики отображения изображений

Приведена в соответствие с `NewsCard.tsx`:

```typescript
const getModalImages = (): string[] => {
  if (!selectedNews) return [];
  const images: string[] = [];
  const cleanBaseUrl = BASE_URL.replace('/api', '');

  // Приоритет для нового формата (массив ID в поле images)
  if (Array.isArray((selectedNews as any).images) && (selectedNews as any).images.length > 0) {
    (selectedNews as any).images.forEach((imageId: string) => {
      if (imageId) {
        const fullUrl = `${cleanBaseUrl}/files/${imageId}`;
        images.push(fullUrl);
      }
    });
  }
  // Fallback для старых форматов
  else if (selectedNews.image_urls && selectedNews.image_urls.length > 0) {
    // ... обработка image_urls
  }
  // ...
}
```

**Изменения:**
- Приоритет отдан полю `images` (массив ID)
- Корректное формирование URL: `{cleanBaseUrl}/files/{imageId}`
- Совместимость со старыми форматами (`image_urls`, `image_url`)

---

## Затронутые файлы

### Изменено:

**src/components/NewsList.tsx**
- Строка 17: Добавлено состояние `abortController`
- Строки 51-95: Переписана функция `handleReadMore` с отменой запросов
- Строки 97-104: Добавлена отмена запроса в `closeModal`
- Строки 106-133: Обновлена функция `getModalImages` для корректной обработки изображений

---

## Тестирование

### Сценарии для проверки:

#### Тест 1: Быстрое переключение между постами
1. Откройте страницу с новостями
2. Быстро кликайте по разным карточкам новостей
3. **Ожидаемый результат:** Модальное окно всегда показывает контент последнего кликнутого поста

#### Тест 2: Клик на пост с медленным интернетом
1. Откройте DevTools → Network → установите Slow 3G
2. Кликните на пост A
3. Через 1-2 секунды кликните на пост B
4. **Ожидаемый результат:** Показывается пост B, а не A

#### Тест 3: Закрытие модального окна во время загрузки
1. Кликните на пост
2. Сразу же закройте модальное окно (кнопка X)
3. **Ожидаемый результат:** Запрос отменяется, нет ошибок в консоли

#### Тест 4: Отображение изображений
1. Кликните на пост с изображениями
2. **Ожидаемый результат:** Изображения загружаются корректно в модальном окне
3. Проверьте URL изображений в DevTools → Network

---

## Преимущества решения

✅ **Предотвращает race condition** - отменяет устаревшие запросы
✅ **Улучшает производительность** - не тратит ресурсы на ненужные запросы
✅ **Улучшает UX** - пользователь всегда видит правильный контент
✅ **Стандартный подход** - использует встроенный в браузеры `AbortController`
✅ **Обратная совместимость** - не ломает существующий функционал

---

## Дополнительные рекомендации

### Для продакшена:
1. Добавить debounce для кликов (предотвратить случайные двойные клики)
2. Показывать индикатор загрузки в модальном окне
3. Добавить кэширование загруженных постов (избежать повторных запросов)

### Пример кэширования:
```typescript
const [postsCache, setPostsCache] = useState<Map<number, NewsDetailPost>>(new Map());

const handleReadMore = async (post: NewsPost) => {
  // Проверяем кэш
  if (postsCache.has(post.id)) {
    setSelectedNews(postsCache.get(post.id)!);
    return;
  }

  // ... загрузка и сохранение в кэш ...
  setPostsCache(prev => new Map(prev).set(post.id, finalDetail));
}
```

---

## Сборка проекта

Проект успешно собирается без ошибок:

```bash
npm run build
✓ 2639 modules transformed.
dist/index.html                   1.57 kB │ gzip:   0.75 kB
dist/assets/index-CBZssFhy.css   91.61 kB │ gzip:  14.83 kB
dist/assets/index-BDzjYcAu.js   889.35 kB │ gzip: 255.67 kB
✓ built in 8.04s
```

---

## Заключение

Баг с отображением неправильного контента в модальном окне полностью исправлен. Использование `AbortController` гарантирует, что пользователь всегда видит контент того поста, на который кликнул последним, независимо от скорости сети и порядка завершения запросов.

Изменения минимальны, обратно совместимы и следуют лучшим практикам React и современного JavaScript.
